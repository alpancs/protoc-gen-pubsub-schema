package main

import (
	"errors"
	"fmt"
	"strings"

	"golang.org/x/exp/slices"
	"google.golang.org/protobuf/types/descriptorpb"
)

type contentBuilder struct {
	*responseBuilder
	file   *descriptorpb.FileDescriptorProto
	output *strings.Builder
}

func newContentBuilder(b *responseBuilder, file *descriptorpb.FileDescriptorProto) *contentBuilder {
	return &contentBuilder{b, file, new(strings.Builder)}
}

func (b *contentBuilder) build() (string, error) {
	if b.file == nil {
		return "", errors.New("contentBuilder.build(): protoFile is nil")
	}

	messageTopLevel := []*descriptorpb.DescriptorProto{}
	messageTypes := b.file.GetMessageType()

	// If the file contains multiple messages
	if len(messageTypes) > 1 {
		// Then, if there's no top-level message specified using the parameter
		if b.messageTopLevel == "" {
			return "", errors.New(b.file.GetName() + ": contains multiple top-level messages and no top-level message is identified, use --pubsub-schema_opt=top-level-message={message} to specify one top-level message.")
		}

		// Because there are multiple top-level messages, lookup the one defined by the top-level-message parameter
		for _, messageType := range messageTypes {
			if *messageType.Name == b.messageTopLevel {
				messageTopLevel = append(messageTopLevel, messageType)
			}
		}
	}

	fmt.Fprintf(b.output, "// Code generated by protoc-gen-pubsub-schema. DO NOT EDIT.\n")
	fmt.Fprintf(b.output, "// versions:\n")
	fmt.Fprintf(b.output, "// 	protoc-gen-pubsub-schema v1.6.0\n")
	fmt.Fprintf(b.output, "// source: %s\n\n", b.file.GetName())
	fmt.Fprintf(b.output, "syntax = \"%s\";\n\n", b.schemaSyntax)
	fmt.Fprintf(b.output, "package %s;\n", b.file.GetPackage())
	b.buildMessages(0, messageTopLevel)
	b.buildEnums(0, b.file.GetEnumType())
	return b.output.String(), nil
}

func (b *contentBuilder) buildMessages(level int, messages []*descriptorpb.DescriptorProto) {
	built := make(map[*descriptorpb.DescriptorProto]bool)
	for _, message := range messages {
		if built[message] {
			continue
		}
		fmt.Fprintln(b.output)
		newMessageBuilder(b, level, message).build()
		built[message] = true
	}
}

func (b *contentBuilder) buildEnums(level int, enums []*descriptorpb.EnumDescriptorProto) {
	built := make(map[*descriptorpb.EnumDescriptorProto]bool)
	for _, enum := range enums {
		if built[enum] {
			continue
		}
		fmt.Fprintln(b.output)
		fmt.Fprintf(b.output, "%senum %s {\n", buildIndent(level), enum.GetName())
		for _, value := range enum.GetValue() {
			fmt.Fprintf(b.output, "%s%s = %d;\n", buildIndent(level+1), value.GetName(), value.GetNumber())
		}
		fmt.Fprintf(b.output, "%s}\n", buildIndent(level))
		built[enum] = true
	}
}

func (b *contentBuilder) isInternalDefinition(field *descriptorpb.FieldDescriptorProto) bool {
	return (field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_MESSAGE ||
		field.GetType() == descriptorpb.FieldDescriptorProto_TYPE_ENUM) &&
		slices.Contains(b.fileTypeNames[b.file], field.GetTypeName())
}

func buildIndent(level int) string {
	return strings.Repeat("  ", level)
}
