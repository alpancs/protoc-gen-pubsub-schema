package main

import (
	"errors"
	"fmt"
	"strings"

	"google.golang.org/protobuf/types/descriptorpb"
)

type contentBuilder struct {
	*responseBuilder
	output *strings.Builder
}

func newContentBuilder(b *responseBuilder) *contentBuilder {
	return &contentBuilder{b, new(strings.Builder)}
}

func (b *contentBuilder) build(protoFile *descriptorpb.FileDescriptorProto) (string, error) {
	if protoFile == nil {
		return "", errors.New("build(protoFile *descriptorpb.FileDescriptorProto): protoFile is nil")
	}

	if len(protoFile.GetMessageType()) != 1 {
		return "", errors.New(protoFile.GetName() + ": only one top-level type may be defined in a file (see https://cloud.google.com/pubsub/docs/schemas#schema_types). use nested types or imports (see https://developers.google.com/protocol-buffers/docs/proto)")
	}

	compVersion := b.request.GetCompilerVersion()
	fmt.Fprintf(b.output, "// Code generated by protoc-gen-pubsub-schema. DO NOT EDIT.\n")
	fmt.Fprintf(b.output, "// versions:\n")
	fmt.Fprintf(b.output, "// 	protoc-gen-pubsub-schema v1.4.4\n")
	fmt.Fprintf(b.output, "// 	protoc                   v%d.%d.%d%s\n", compVersion.GetMajor(), compVersion.GetMinor(), compVersion.GetPatch(), compVersion.GetSuffix())
	fmt.Fprintf(b.output, "// source: %s\n\n", protoFile.GetName())
	fmt.Fprintf(b.output, "syntax = \"%s\";\n\n", b.schemaSyntax)
	fmt.Fprintf(b.output, "package %s;\n", protoFile.GetPackage())
	b.buildMessages(protoFile.GetMessageType(), 0)
	b.buildEnums(protoFile.GetEnumType(), 0)
	return b.output.String(), nil
}

func (b *contentBuilder) buildMessages(messages []*descriptorpb.DescriptorProto, level int) {
	built := make(map[*descriptorpb.DescriptorProto]bool)
	for _, message := range messages {
		if built[message] {
			continue
		}
		fmt.Fprintln(b.output)
		newMessageBuilder(b, message, level).build()
		built[message] = true
	}
}

func (b *contentBuilder) buildEnums(enums []*descriptorpb.EnumDescriptorProto, level int) {
	built := make(map[*descriptorpb.EnumDescriptorProto]bool)
	for _, enum := range enums {
		if built[enum] {
			continue
		}
		fmt.Fprintln(b.output)
		fmt.Fprintf(b.output, "%senum %s {\n", buildIndent(level), enum.GetName())
		for _, value := range enum.GetValue() {
			fmt.Fprintf(b.output, "%s%s = %d;\n", buildIndent(level+1), value.GetName(), value.GetNumber())
		}
		fmt.Fprintf(b.output, "%s}\n", buildIndent(level))
		built[enum] = true
	}
}

func buildIndent(level int) string {
	return strings.Repeat("  ", level)
}
